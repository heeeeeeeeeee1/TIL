# 풀이 1
# 가장 큰 값의 인덱스(i_max) 구하기
# 가장 큰 값(i_max) 전까지 나온 모든 값들과의 차이(이익)를 result에 누적합하기
# 남은 값들 중 i_max 다시 구하고, 위의 과정 반복
# 최대이익 출력
T = int(input())    # 테스트 케이스
for tc in range(1,T+1):
    N = int(input())    # 매매가 개수
    price = list(map(int, input().split())) # 매매가

    result = 0  # 결과 누적합
    start = 0   # 시작 인덱스
    while start < N:                            # 시작 인덱스가 N(매매가 개수)보다 같거나 커지면 반복 종료(== N-1까지 반복)
        i_max = start                           # 최댓값의 인덱스 초기값 설정. 0으로 하면 안됨(한 리스트에서 다음 순회로 넘어가야하기 때문. 0으로 하면 계속 같은 시작점으로 돌아감)
        for i in range(start+1, N):             # start+1: 현재 위치(start)는 자기 자신(최댓값 인덱스)이라서 그 다음부터 순회
            if price[i_max] < price[i]:         # 지금의 최댓값 보다 방금 순회한 값이 더 크다면
                i_max = i                       # 방금 순회한 값의 인덱스로 최댓값 인덱스 갱신
        for i in range(start, i_max):           # 최댓값 인덱스 구했으면 최대이익 구해야지///순회 시작점부터 최댓값 전까지 순회
            profit = price[i_max] - price[i]    # 이익
            result += profit                    # 최대이익 만들기(누적합)
        start = i_max + 1                       # 이어서 순회하기 위한 인덱스 설정


    print(f'#{tc} {result}')

#-------------------------------------------------------------------------------------
# 풀이2
# 뒤쪽부터 탐색 => price 한번만 루프 돌면 됨
# 풀이1은 최악의 경우 끝까지 순회했는데 맨 앞쪽이 최댓값이면, 끝까지 순회하고 다시 돌아와서 이익 한번 구하고 다시 또 순회하고 반복하게됨. 이중루프 오래걸림
T = int(input())                                # 테스트 케이스
for tc in range(1, T+1):
    N = int(input())                            # 매매가 개수
    price = list(map(int, input().split()))     # 매매가

    result = 0
    i_max = -1
    for i in range(N-1, -1, -1):                # 뒤에서부터 순회
        if price[i_max] > price[i]:             # 맨 끝값을 초기값으로 설정. 거꾸로 순회하다가 현재값보다 작은애 나오면 빼주고, 큰값나오면 최댓값으로 갱신
            result += (price[i_max] - price[i]) # 현재 값보다 작으면 이익 구해서 누적합
        else: # 아니라면(같거나 크다면) 아 같은경우는..?
            # price[i_max] < price[i]
            i_max = i   # 걔로 최댓값 갱신

    print(f'#{tc} {result}')
'''
리뷰
1. 처음에는 하나씩 순회하면서 담고 최댓값 나오면 이전 값들과의 차이를 구하면 되지 않을까 라고 생각했는데 더 복잡해지는 것 같아서 포기 
2. 사고를 원활히 할 수 없어서 문어박사 유튜브 참고
3. 이게 왜 큐와 관련되어있는지는 잘 모르겠음

풀이1 : 앞에서부터 순회하면서 최댓값을 찾기때문에 리스트의 끝까지 다 순회해야함(시간복잡도 n^2). 뒤에 더 큰 값이 나올 수 있으니까
풀이2 : 뒤에서부터 순회하면 기준값보다 작은 값이 나오면 바로 뺄셈해주어 이익 구하면 됨(시간복잡도 n)

'''