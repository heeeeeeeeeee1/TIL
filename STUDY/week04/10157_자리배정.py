# 대기순서 K인 관객 좌석번호(x, y) 찾기
# 공연장 격자 크기
C, R = map(int, input().split())

# 대기번호
K = int(input())

# 모든 좌석이 배정되어 해당 대기번호의 관객에게 좌석을 배정할 수 없는 경우에는 0출력
if C*R < K:
    print(0)
else:
    # 배열 테두리에 1로 둘러싸기 => 범위 벗어난지 확인하는 조건 시간 오래걸림. 테두리를 1로 둘러싸면 0일때 숫자 작성한다는 조건만 고려하면 됨
    # C x R 배열 만들기
    arr = [[1]*(C+2)] + [[1] + [0]*C + [1] for _ in range(R)] + [[1]*(C+2)]

    # 그림처럼 배치할 필요 없음.?.?
    # 하 우 상 좌
    dr = [1, 0, -1, 0]
    dc = [0, 1, 0, -1]

    # 시작 위치
    r, c = 1, 1

    # 시작할 방향 인덱스
    dir = 0

    # 순회하면서 숫자 +1해서 기준위치(r,c)에 넣기
    # 범위 벗어나거나 0이 아니면 방향전환
    # 테두리를 1로 둘러주어 범위와 관련된 조건을 고려할 필요없어짐
    for n in range(1, K):
        arr[r][c] = n           # 채워가는 숫자(값) n
        nr = r + dr[dir]
        nc = c + dc[dir]
        if arr[nr][nc] == 0:    # 0이면
            r, c = nr, nc       # 이동하고
        else:                   # 범위 밖(1로 둘러쌈) 또는 이미 기록한 위치(숫자 입력되어있음)
            dir = (dir + 1)%4   # 델타 방향 인덱스 이동(==방향꺾기) 다시 0으로 돌아와야 하므로 4로 나눈 나머지
            r, c = r + dr[dir], c + dc[dir]

    print(f'{c} {r}')