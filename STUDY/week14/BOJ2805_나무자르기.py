# 1. 제일 낮은 값(1)과 제일 높은 나무를 범위로 잡는다.
# 2. 이 범위의 중간값이 자를 높이
# 3. 이 중간값을 이용해서 자른 나무 길이들의 합을 구한다.
# 4. 잘린 나무들의 합이 우리가 원하는 것보다 많으면 자를 높이를 더 높이고, 적으면 자를 높이를 낮춘다.
# 5. 자를 높이가 정확해질 때까지 반복

N, M = map(int, input().split())    # N: 나무의 수, M: 상근이가 집으로 가져가려고 하는 나무 길이
trees = list(map(int,input().split()))  # 나무 N개 높이 담긴 리스트

start = 1                       # M이 1보다 크므로 1부터 시작
end = max(trees)                # 가장 높은 나무를 기준으로

while start <= end:
    mid = (start + end) // 2    # mid(중간값)만큼 자를거야

    pieces = 0
    for tree in trees:              # 리스트에서 나무 하나씩 가져와
        if tree > mid:              # 나무가 mid 보다 길다면
            pieces += (tree - mid)  # 자르고, 잘린 나무들 누적해서 더함

    if pieces >= M:     # 잘린 나무 조각들의 합이 M(상근이가 가져가려는 나무 길이)보다 크거나 같으면
        start = mid + 1 # 탐색 범위(자를 높이)를 더 큰 값 쪽으로 이동
    else:               # 누적된 나무 길이가 M보다 작다면, 더 많이 잘라야 함
        end = mid - 1   # 탐색 범위를 더 낮은 값 쪽으로 이동(낮아지면 나무 더 자를 가능성이 커지겠지?)

print(end)

'''
리뷰
1. python3으로 하니까 시간초과 -> pypy 통과
1-1. sys.stdin.readline() 썼어야 하나?
2. 왜 mid가 아닌 end를 출력해야 하는가 /// trees = [20 15 10 17], start = 1, end = 20
2-1. mid = 10, 자른 길이 총합이 22로 M = 7보다 크므로 start = mid + 1 = 11
2-2. mid = 15, 자른 길이 총합이 7로 M에 딱 맞으므로 start = mid + 1 = 16
2-3. mid = 18, 자른 길이 총합이 2로 end = mid - 1 = 17
2-3. mid = 16, 자른 길이 총합이 5로 end = mid - 1 = 15
2-4. start = 16, end = 15로 start > end가 되어 루프 종료
2-5. 그래서 M에 딱 맞았다고 해서 바로 종료하지 않는 이유가 뭐야? 이진탐색이기 때문이야?
3. 기본코드 보고 이진탐색 이해 했다고 생각했는데 살짝 달라졌다고(잘린 부분 고려) 문제에 적용을 못함.
3-1. 서칭 + 참고
'''





