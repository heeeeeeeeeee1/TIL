## 인증과 인가

### 1. 실생활 비유로 인증과 인가 이해하기
- `인증`은 식별 가능한 정보로 서비스에 등록된 사용자의 신원을 입증하는 과정이다. 사원이름, 증명사진(사원증)으로 회사직원인지 입증하는 과정과 같다고 볼 수 있다.
- `인가`는 인증된 사용자가 어떤 자원에 접근할 수 있는지를 결정하는 과정으로, 출입증이 특정 층에만 허용된다는 예시가 이에 해당된된다. 즉, 인가는 인증된 사용자에 대한 자원 접근 권한을 확인하는 것이다.

</br>

### 2. 인증과 인가의 웹 적용 예시(게시판)
- 사용자 인증 과정은 게시판 서비스에서 회원 가입과 로그인을 통해 이루어지며 로그인 과정이 `인증`에 해당한다.
- 사용자는 로그인 후 글을 작성할 수 있지만 다른 사람의 글을 수정할 권한은 없다. 이는 `인가` 개념을 나타낸다.
- 인증과 인가는 자원을 적절한/유효한 사용자에게 전달/공개 하기 위한 방법이다.
- (인증은 인가보다 선행되는 개념이다.)

</br>

### 3. 인증의 방법

cf. 사전지식
- HTTP(HyperText Transfer Protocol) : 클라이언트와 서버 간의 요청 및 응답을 주고받는 프로토콜
- 무상태성(Stateless) : 서버는 클라이언트가 보낸 요청과 이 다음 요청에 대한 연관관계가 없다. (HTTP는 각 요청이 독립적으로 처리되며 서버는 이전 요청의 상태를 기억하지 않는 특징이 있다.)
- 상태성(Stateful) : 서버가 클라이언트의 이전 요청 정보를 기억하고 있는 특성을 의미한다.


### 3.1. Request Header
- 사용자가 로그인 요청을 보낼 때 id, pw를 입력해 서버에 전달하는 방식이다.(예: <사용자id:pw>http://wwww.example.com/login)
  1. 이 url에서 id,pw를 파싱해 인코더(Base64)로 변환(브라우저에서 처리) 후 요청 헤더(Request header)에 넣어서 전달한다. (예: Authorization: Basic 인코딩된 문자열)
  2. 서버는 전달받은 정보를 DB에서 조회 후 일치하면 인증을 승인한다.
- 이 방식은 매 요청마다 인증해줘야 한다.(예: 글쓰기 요청 시 인증, 글 수정 요청 시 재인증)

### 3.2. Browser 활용하기: 쿠키
- 브라우저의 스토리지에는 로컬 스토리지, 세션 스토리지, 쿠키 등이 있으나 쿠키를 예로 들겠다.
- 사용자가 로그인 후 브라우저에 인증 정보를 저장하여 이후 요청 시 자동으로 인증 정보를 전달하는 방식이다.
  1. 로그인 후 서버는 사용자의 ID와 비밀번호를 포함한 인증 정보를 쿠키에 저장한다.
  2. 이후 요청마다 브라우저가 쿠키를 서버에 자동으로 전달한다.
  3. 서버는 쿠키에 포함된 정보를 바탕으로 사용자를 인증한다.
- 사용자는 로그인 후 브라우저의 스토리지(쿠키)를 활용해 인증 정보를 유지할 수 있지만 보안에 취약할 수 있다. 해커가 쿠키를 탈취하면 사용자의 계정을 쉽게 도용할 수 있기 때문이다.

### 3.3. Server: Session
- 사용자 정보를 서버 측에서 관리하여 앞선 방법보다 보안성이 높다.
  1. 사용자가 로그인 요청을 보내면 서버는 사용자의 식별자와 랜덤 문자열로 구성된 세션ID를 생성한다.
  2. 클라이언트가 이 세션ID를 저장한다.
  3. 이후 클라이언트는 요청마다 세션ID를 서버에 전달한다.
  4. 서버는 세션 저장소에서 해당 세션의 유효성을 확인하여 인증 여부를 판단한다.
      - 한 번 인증해서 세션을 받았을 때, 다음 요청은 세션으로만 이용해서 요청한다.(DB 체킹과정 불필요)

- 장점1: 클라이언트는 사용자의 원시 데이터(실제 사용자의 아이디, 비밀번호)를 보유하지 않게 되어 해커가 정보를 탈취하더라도 큰 위험이 없어진다.
- 장점2: 세션의 만료기간을 설정하여 해당 기간이 지나면 해커가 세션을 가져가더라도 유효하지 않게 된다.
- 장점3: 서버 측에서 세션을 관리하기 때문에 탈취된 세션을 서버에서 삭제하면 해당 세션을 더 이상 사용할 수 없게 되어 보안상 이점이 있다.


- 단점1: 여러 서버가 운영되는 서비스의 경우 세션 관리가 복잡해질 수 있다. 로드밸런서가 인증이 필요한 요청을 서로 다른 서버로 전달하면(ex. 3개의 서버 중 첫번째 요청은 3번 서버 두번째 요청은 2번 서버. 세션ID는 3번 서버에만 있는 상태) 인증 정보가 공유되지 않을 수 있다.
</br>(cf. 로드밸런싱: 한 곳의 서버에 트래칙이 몰리는 것을 방지하고 여러 서버에 적절히 분산시켜주는 기술)
  - 이런 문제의 원인은 각 서버가 단독으로 세션을 관리하기 때문에 발생한다. 이를 해결하기 위해 세션 저장소를 도입하여 모든 세션을 중앙에서 관리할 수 있다.

- 단점2: 하지만 사용자가 많아지면 인증 및 인가 절차의 부담이 증가하기 때문에 여전히 세션 관리에 어려움이 생긴다.

### 3.4. REST API와 인증, 인가의 상태 관리
- REST API는 기본적으로 무상태성을 가지므로 각 요청이 독립적으로 처리되어야 한다.(예: 쇼핑몰API에서 1번 상품 정보 요청과 2번 상품 정보 요청은 독립적으로 처리된다.) 하지만 인증과 인가는 본질적으로 상태를 유지해야 하는 특성이 있다.(예: 주문 생성 요청, 내 프로필 조회 요청 등과 같은 경우 사용자가 로그인했다는 상태를 계속 기억해야한다.) 이러한 모순을 해결하기 위해 토큰 기반 인증 방식이 도입되었다. 토큰은 각 요청에 필요한 인증 정보를 포함하기 때문에 서버가 상태를 유지할 필요 없이 각 요청을 독립적으로 처리할 수 있게 한다.


### 3.5. Token 활용하기
#### 3.5.1. JWT(Jason Web Token)와 시크릿 키의 역할
- JWT는 인증과 인가를 위한 중요한 도구이며 `시크릿 키`(토큰의 서명을 생성하고 검증하는데 사용되는 서버만이 가지고 있는 비밀값)를 사용하여 생성되고 인증된다.
- JWT는 해독이 쉬우므로 민감한 정보(예: 비밀번호)는 포함하지 않아야 한다.
- 시크릿 키의 노출은 JWT의 보안성을 위협하므로 반드시 서버 내부에서 철저히 관리해야 한다.

#### 3.5.2. ️JWT의 인증 및 유효성 검사 과정
- 사용자가 로그인하면 요청이 DB로 전송되며, 시크릿키를 통해 토큰이 생성된다.
- JWT는 클라이언트에서 서버로 전송되며 서버는 시크릿키를 이용해 이 토큰의 유효성을 검사한다.
- 유효한 토큰일 경우, 사용자 정보(이름, 만료시기, 권한)를 확인할 수 있다.
- 시크릿 키를 통해서 유효성 검사를 통과한 토큰은 인증이 완료된 상태의 토큰으로 간주된다.
- 비밀번호와 같은 민감한 정보는 토큰에 포함되어서는 안 되며, 이는 디코딩이 용이하여 노출될 위험이 있기 때문이다.

#### 3.5.3. JWT의 장점과 단점
- 장점1:여러 대의 서버가 사용자의 요청을 각자 가진 시크릿 키로 해독하여 인증을 수행할 수 있다.
- 장점2: 확장성이 뛰어난 시스템을 구성할 수 있다는 점이 있다.(서버가 증가해도 똑같이 시크릿 키로 각자 해독해서 인증 수행하면 된다.)
- 단점1: `액세스 토큰`이 탈취되면 해커가 사용자와 같은 권한을 가지게 된다.
- 단점2: 단점1을 방지하기 위해 만료 기한을 설정하는데, 예를 들어 30분의 만료 기한을 두게 되면 해커는 토큰을 사용할 수 없지만 사용자 역시 동일하게 영향을 받게 되어 불편함이 발생할 수 있다.
</br>=> 리프래시 토큰 사용

#### 3.5.4. 리프레시 토큰의 작동 방식
- 로그인 시 서버는 액세스 토큰과 리프레시 토큰 모두 생성한다.
- 서버는 리프레시 토큰만 저장하고, 액세스 토큰은 저장하지 않는다.
- 두 토큰 모두 응답헤더로 클라이언트에 전송되어 저장된다.
- 클라이언트는 액세스 토큰을 사용해서 요청을 보낸다.
- 액세스 토큰이 만료되면 클라이언트는 리프레시 토큰과 함께 서버로 요청을 보내고, 서버는 이를 검토하여(DB 확인 후) 새로운 액세스 토큰을 발급한다.
- 장점: 별도의 세션 관리가 필요 없게 하여 빠른 속도를 제공한다.
- 단점: 토큰도 보안 관리가 필요하므로 지속적인 주의가 필요하다.

