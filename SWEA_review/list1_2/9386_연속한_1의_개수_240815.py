# 연속한 1의 개수 중 최대값 출력
# 테스트 케이스
T = int(input())

for tc in range(1, T+1):
    # 수열의 길이
    N = int(input())

    # 0,1 수열
    seq = list(map(int,input()))

    max_len = 0

    # 연속된 1의 개수 중 가장 긴 것 찾기
    # 1이 연속되다가 0 나오면 끊기고, 다음에 1 다시 나올때 다시 카운팅 되어야함.
    # 그렇다면 초기값 위치는 어디?
    result = 0
    for s in seq:   # 수열에서 0, 1 가져오기
        # 여기있으면 계속 초기화 되는디
        if s == 1:  # 1이라면
            result += 1
            if max_len < result:
                max_len = result
        else:       # 0이라면
            result = 0  # 지나가

    print(f'#{tc} {max_len}')   # 맞게 작성했는데 출력을 result로 해놨잖아?ㅋ


    # 연속된 1의 길이를 리스트에 담아서 최댓값 찾아도 되고
    # 바로 갱신해서 최댓값 하나만 출력되게 해도 될듯 <- 이 방법으로 진행

    # 위 코드처럼 하게 되면 1을 카운팅함과 동시에 최댓값을 갱신하는데,
    # 연속된 1의 개수를 다 세고 최댓값 비교하고 싶어서 고민해봤으나
    # ex. 0011001110 이라면 result: 1 되고 max_len: 1 되는데 그게 아니라 0나오면 연속된 1의 길이가 2 되니까 이떄의 2랑 max_len 초기값(0)이랑 비교하고 싶은거
    # 그러려면 리스트로 만들어야 하는듯?
    # else에서 result 초기화를 안해주면 1 나오다가 0 나오고 다시 1을 만났을때 이전에 누적되어있던 result 값에 이어서 더해짐
    # 최댓값 갱신 조건을 else에 넣게 되면 수열의 마지막 값이 1로 끝나는 경우 else 조건이 진행되지 않아서 값이 달라짐
