# 1. 철수 빙고판(2차원 배열) 만들기
# 2. 사회자는 2차원 배열일 필요 없으므로 리스트로 입력받기
# 3. 가로, 세로, 대각선으로 순회하고 값이 사회자의 숫자와 같으면 좌표 저장 리스트(pos_list)에 저장
# 4. 행, 열, 대각선 빈도수 체크할 배열 2차원으로 생성(v0 ~ v3)

# 1 ~ 5줄 입력: 철수
bingo = [list(map(int, input().split())) for _ in range(5)]

# 6 ~ 10줄: 사회자
bingo_ans = []
for _ in range(5):
    bingo_ans += list(map(int, input().split()))    # 1차원으로 생성/저장

# 번호마다 좌표의 위치를 튜플로 저장
pos_list = [0] * 26                     # 1부터 25까지 저장. 0은 비겠네
for i in range(5):
    for j in range(5):
        pos_list[bingo[i][j]] = (i, j)  # pos_list[11] = (0, 0)

v = [[0]*10 for _ in range(4)]  # v0 ~ v3 빈도수 체크

result = 0
# 사회자가 부르는 좌표를 읽어서 빈도수 체크, 5인 개수가 3이상이면 빙고
for num in bingo_ans:     # num: 사회자가 부르는 번호
    i, j = pos_list[num]  # 번호에서 좌표를 읽어옴. 사회자가 부르는 번호를 철수 빙고판 좌표를 저장한 리스트에서
    v[0][j] += 1          # 세로(열) 개수를 누적
    v[1][i] += 1          # 가로(행) 개수를 누적
    v[2][i-j] += 1        # 대각선 \ 개수를 누적
    v[3][i+j] += 1        # 대각선 / 개수를 누적
    result += 1           # 사회자가 부를 때마다 +1

    # v(2차원 배열) 순회하며 누적개수가 5인 개수 세기
    line = 0
    for lst in v:             # 2차원 배열 v에서 리스트(v0 ~ v3)로 가져옴
        line += lst.count(5)  # 값이 5이면 선 긋기

    # 사회자가 몇 번째 수를 부른 후 철수가 빙고를 외치게 되는지 출력
    if line >= 3:             # 선 3개이상 그었을때 빙고
        print(result)         # 사회자가 부른 번호가 몇번째인가 => 지금까지 누적된 개수가 즉, 사회자가 부른 번호의 순서
        break                 # 선 3개 이상이면 계속 출력되니까 최초로 빙고 외치고 끝

'''
리뷰
1. 문제풀이 영상 참고했음에도 어려움
2. 빈 리스트를 이렇게 만들 생각을 못함
3. v 배열을 10칸으로 만든이유? 대각선 파악할때 가운데 대각선뿐만아니라 다른 작은 대각선들도 고려하면 9칸 필요하기 때문
3-1. 대각선 배열 파악할때 음수 인덱스도 섞이게 되는데 이 문제에서는 숫자 5개가 선 1개여서 음수 인덱스는 신경쓰지 않아도 되긴 하지만...
그러면 2차원으로 한번에 생성했는데 v2의 인덱스는 어떻게 되는거지?
4. 무엇을 구하려고 만든 배열인지, 무엇을 출력해야하는지 명확히 인지하지 못하는 것을 보니, 논리구조가 제대로 잡혀있지 않은듯
'''