# 충전해서 N까지 가야되는건데
# 인덱스 0일때는 무조건 충전했다고 침(노 카운트)
# 충전기가 있으면 충전(charge+=1) -> k만큼 전진
# (K만큼 이동해서 간 자리에) 충전기 없으면 근처에 충전기 있는지 확인
# 있으면 거기로 이동해서 충전(charge+=1) -> k만큼 전진
# 없으면 stop
# 종점에 도착할 수 없는 경우 0 출력
# 최소 충전 횟수 구해야되니까 한번 충전해서 최대한 멀리가야겠네

'''
test) 최대로 몇 번째 구역에 이동할 수 있는지
n보다 큰 경우(도착점 이상으로 갈 경우) n출력
도착점 못 간 경우 현재위치 i(최대로 많이 간 거리) 출력
'''

T = int(input())
for tc in range(1, T + 1):
    k, n, m = map(int, input().split())
    lst = list(map(int, input().split()))

    # 충전소가 있으면 1 없으면 0
    station = [0] * (n+1)  # 0번째 인덱스(출발점)에서는는 항상 충전된 상태로 출발
    for a in lst:  # 충전소가 있다면
        station[a] = 1  # 해당 인덱스에 1(있다고) 표시
    # print(station)

    # 일단 station 전진
    i = 0  # 모든 버스는 0에서 시작. 만큼 이동
    charge = 0
    while i < n:  # 언제 종료됨? 여기 틀렸나. 더 이상 전진할 수 없으면 종료되는건데. 예를 들어 9에서 3 전진했으면 어차피 n초과니까 반복문 정지되거 아니야?
        if i == 0:      # 출발점이면
            i = i + k   # charge 증가하지 않고 그냥 k만큼 전진
        else:
            if station[i] == 1:  # 충전기가 있다면
                charge += 1      # 충전하고
                i = i + k        # 전진
            else:                # station[i] == 0:
                for j in range(i - 1, i - k, -1):   # 이전으로 돌아가서
                    if station[j] == 1:             # 1 있는지 확인. 1이면
                        charge += 1                 # 충전하고
                        i = j + k                   # 전진
                        break   # 여기서 break 걸어야 하나. 되돌아갈 때 내 위치 기준 가장 가까운 1에서 충전하고 다시 전진하면 되는데
                                # 1이 아니라면 다음 순회 이어서.

                else:   # 순회 다했는데 1없으면 이전으로 되돌아가도 1 없으면 더 이상 못감
                    charge = 0  # 도착지 도착 불가 # charge = 0으로 할까 생각했는데 그럼 초기화 될까봐 다른 변수 둠.
                    break

    if i > n:
        i = n

    print(f'#{tc} {i}')

'''
리뷰
1. 문제를 살짝 수정해봄
2. 마지막 if문처럼 해도 되는거야? -> 됨
 
'''